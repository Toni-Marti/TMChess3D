import * as THREE from "../libs/three.module.js";
import * as Pieces from "./Objects/Pieces/AllPieces.js";
import * as PiceMaterialSets from "./Objects/Pieces/Materials/MaterialSetLibrary.js";
import { Board } from "./Objects/Board.js";

class MyScene extends THREE.Scene {
  constructor(myCanvas) {
    super();
    this.mouse = new THREE.Vector2();
    this.raycaster = new THREE.Raycaster();
    this.renderer = this.createRenderer(myCanvas);
    this.createLights();
    this.createCamera();
    this.axis = new THREE.AxesHelper(1);
    this.add(this.axis);
    this.currentTurn = "white"; 
    this.highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green highlight
    this.normalMaterials = {}; // To store original square materials

    this.board = new Board();
    this.board.name = "chessBoard";
    this.add(this.board);
    this.createPieces();
  }

  rotateCameraAroundBoard() {
    const radius = 13; 
    const height = 10;
    const center = new THREE.Vector3(0, 0, 0);
    const duration = 2000; 
  
    const startAngle = this.currentTurn === "white" ? Math.PI : 0;
    const endAngle = this.currentTurn === "white" ? 0 : -Math.PI;
  
    const startTime = performance.now();
  
    const animate = (time) => {
      const elapsed = time - startTime;
      const t = Math.min(elapsed / duration, 1);
      const angle = startAngle + (endAngle - startAngle) * t;
  
      const x = radius * Math.sin(angle);
      const z = radius * Math.cos(angle);
      this.camera.position.set(x, height, z);
  
      // Ahora, sin controles, sólo usamos lookAt para enfocar el centro
      this.camera.lookAt(center);
  
      if (t < 1) {
        requestAnimationFrame(animate);
      }
    };
  
    // Alternar turno antes de iniciar animación
    this.currentTurn = this.currentTurn === "white" ? "black" : "white";
  
    requestAnimationFrame(animate);
  }
  
  createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.01,
      1000
    );
<<<<<<< Updated upstream
    this.camera.position.set(0, 12, -13);
=======
    this.camera.position.set(0.7, 0.7, 0.7);
>>>>>>> Stashed changes
    var look = new THREE.Vector3(0, 0, 0);
    this.camera.lookAt(look);
    this.add(this.camera);

  }

  createPieces() {
    let i = 0;

    let white_set = PiceMaterialSets.classic_white;
    let black_set = PiceMaterialSets.classic_black;

    this.createRow(white_set, 0, 1, "white");
    this.createRow(black_set, 7, 6, "black");
  }

  createRow(material_set, row, pawnRow, color) {
    let pieces = [
      new Pieces.Rook(material_set.clone(), row, 0),
      new Pieces.Knight(material_set.clone(), row, 1),
      new Pieces.Bishop(material_set.clone(), row, 2),
      new Pieces.Queen(material_set.clone(), row, 3),
      new Pieces.King(material_set.clone(), row, 4),
      new Pieces.Bishop(material_set.clone(), row, 5),
      new Pieces.Knight(material_set.clone(), row, 6),
      new Pieces.Rook(material_set.clone(), row, 7),
    ];

    for (let i = 0; i < 8; i++)
      pieces.push(new Pieces.Pawn(material_set.clone(), pawnRow, i));

    const scale_factor = 0.5 / 8;
    for (let piece of pieces) {
      let row = piece.row;
      let col = piece.col;
      piece.scale.set(
        piece.scale.x * scale_factor,
        piece.scale.y * scale_factor,
        piece.scale.z * scale_factor
      );
      let square_position = this.board.squares[row][col].position;
      piece.position.set(square_position.x, 0, square_position.z);
      piece.name = "piece";
      if (color === "black") {
        piece.rotation.y = Math.PI;
      }
      this.add(piece);
    }
  }

 onMouseMove(event) {
  const rect = this.renderer.domElement.getBoundingClientRect();
  this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
}


  createLights() {
    this.ambientLight = new THREE.AmbientLight("white", 0.5);
    this.add(this.ambientLight);

    this.pointLight = new THREE.PointLight(0xffffff, 1, 0, 0);
    this.pointLight.position.set(-10, 10, 1.5);
    this.add(this.pointLight);
  }

  createRenderer(myCanvas) {
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(new THREE.Color(0xffffff), 1.0);
    renderer.setSize(window.innerWidth, window.innerHeight);
    $(myCanvas).append(renderer.domElement);

    return renderer;
  }



  onClick(event) {
    // Clean up previous ray visualization
    this.cleanupRayVisualization();

    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObjects(this.children);
<<<<<<< Updated upstream

    // Visualize ray and collisions
    this.visualizeRay(intersects);

    const validPieceNames = [
      "white_king",
      "white_queen",
      "white_bishop1",
      "white_bishop2",
      "white_knight1",
      "white_knight2",
      "white_rook1",
      "white_rook2",
      "white_pawn1",
      "white_pawn2",
      "white_pawn3",
      "white_pawn4",
      "white_pawn5",
      "white_pawn6",
      "white_pawn7",
      "white_pawn8", // Peones blancos
      "black_king",
      "black_queen",
      "black_bishop1",
      "black_bishop2",
      "black_knight1",
      "black_knight2",
      "black_rook1",
      "black_rook2",
      "black_pawn1",
      "black_pawn2",
      "black_pawn3",
      "black_pawn4",
      "black_pawn5",
      "black_pawn6",
      "black_pawn7",
      "black_pawn8", // Peones negros
    ];

=======
>>>>>>> Stashed changes

    // Visualize ray and collisions
    this.visualizeRay(intersects);

    // Original code continues...
    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;
      // console.log("Clicked object:", clickedObject.name);
      if (this.selectedPiece) {
        if (clickedObject.name.startsWith("square_")) {
          const targetPos = clickedObject.position.clone();
          this.selectedPiece.position.set(targetPos.x, 0, targetPos.z);
          this.selectedPiece.position.y = 0;
          this.selectedPiece = null;
          this.resetSquareHighlights();
          this.rotateCameraAroundBoard();
        }
        return;
      }
      let piece = this.isPiece(clickedObject);
      if (piece) {
        piece.position.y = 2;
        this.selectedPiece = piece;
        this.highlightAllSquares();
        return;
      }
    }
    if (this.selectedPiece) {
      this.selectedPiece.position.y = 0;
      this.selectedPiece = null;
      this.resetSquareHighlights();
    }
  }

  highlightAllSquares() {
    const board = this.getObjectByName("chessBoard");

    board.traverse((child) => {
      if (child.isMesh && child.name.startsWith("square_")) {
        // Save original emissive color
        this.normalMaterials[child.uuid] = child.material.emissive
          ? child.material.emissive.clone()
          : new THREE.Color(0x000000);

        if (child.material.emissive) {
          child.material.emissive.set(0x00ff00);
          child.material.emissive.set(0x00ff00);
        }
      }
    });
  }

  resetSquareHighlights() {
    const board = this.getObjectByName("chessBoard");

    board.traverse((child) => {
      if (child.isMesh && child.name.startsWith("square_")) {
        const originalEmissive = this.normalMaterials[child.uuid];
        if (child.material.emissive && originalEmissive) {
          child.material.emissive.copy(originalEmissive);
        }
      }
    });

    this.normalMaterials = {}; // Clear saved emissives
  }

  isPiece(object) {
    /**
     * Check if the object is a piece
     *
     * @returns {THREE.Object3D|null} The piece object if found, otherwise null
     */
    let current = object;
    while (current) {
      if (current.name == "piece") {
        return current;
      }
      current = current.parent;
    }
    return null;
  }

  getCamera() {
    return this.camera;
  }

  setCameraAspect(ratio) {
    this.camera.aspect = ratio;
    this.camera.updateProjectionMatrix();
  }

  onWindowResize() {
    this.setCameraAspect(window.innerWidth / window.innerHeight);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  update() {
    this.renderer.render(this, this.getCamera());
    requestAnimationFrame(() => this.update());
  }

  cleanupRayVisualization() {
    // Remove ray line if it exists
    if (this.rayLine) {
      this.remove(this.rayLine);
      this.rayLine = null;
    }

    // Remove collision markers if they exist
    if (this.collisionMarkers) {
      this.collisionMarkers.forEach((marker) => this.remove(marker));
      this.collisionMarkers = [];
    }
  }

  visualizeRay(intersects) {
    // Create ray line
    const rayOrigin = this.raycaster.ray.origin.clone();
    const rayDirection = this.raycaster.ray.direction.clone().normalize();
    const rayLength = 100; // Make ray long enough to see
    const rayEnd = rayOrigin
      .clone()
      .add(rayDirection.clone().multiplyScalar(rayLength));

    const rayGeometry = new THREE.BufferGeometry().setFromPoints([
      rayOrigin,
      rayEnd,
    ]);
    const rayMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red ray
    this.rayLine = new THREE.Line(rayGeometry, rayMaterial);
    this.rayLine.name = "raycasterRay";
    this.add(this.rayLine);

    // Create collision markers
    this.collisionMarkers = [];
    intersects.forEach((intersect, index) => {
<<<<<<< Updated upstream
      const markerGeometry = new THREE.SphereGeometry(0.2, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: index === 0 ? 0xff0000 : 0xffff00, // First collision green, others yellow
=======
      const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: index === 0 ? 0x00ff00 : 0xffff00, // First collision green, others yellow
>>>>>>> Stashed changes
      });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.copy(intersect.point);
      marker.name = "collisionMarker";
      this.collisionMarkers.push(marker);
      this.add(marker);
    });
  }
}

$(function () {
  var scene = new MyScene("#WebGL-output");
  window.addEventListener("resize", () => scene.onWindowResize());
  window.addEventListener("click", (event) => scene.onClick(event));
  window.addEventListener("mousemove", (event) => scene.onMouseMove(event));
  scene.update();
});
